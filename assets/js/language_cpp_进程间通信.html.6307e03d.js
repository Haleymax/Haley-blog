"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[188],{6262:(s,i)=>{i.A=(s,i)=>{const n=s.__vccOpts||s;for(const[s,a]of i)n[s]=a;return n}},9373:(s,i,n)=>{n.r(i),n.d(i,{comp:()=>t,data:()=>h});var a=n(641);const e=[(0,a.Fv)('<h1 id="线程间通信" tabindex="-1"><a class="header-anchor" href="#线程间通信"><span>线程间通信</span></a></h1><h2 id="_1-锁机制-mutex" tabindex="-1"><a class="header-anchor" href="#_1-锁机制-mutex"><span>1.锁机制（mutex）</span></a></h2><h3 id="_1-1-基本互斥锁std-mutex" tabindex="-1"><a class="header-anchor" href="#_1-1-基本互斥锁std-mutex"><span>1.1 基本互斥锁<code>std::mutex</code></span></a></h3><p><code>std::mutex</code>是最基本的互斥变量，他提供了最基本的互斥访问控制。</p><p>特点如下：</p><ul><li><p><strong>互斥访问：</strong> 只有一个线程可以锁定<code>std::mutex</code>对象，其他线程必须等待解锁后才能继续执行。</p></li><li><p><strong>不可重入：</strong> 同一个线程不能多次锁定同一个<code>std::mutex</code>否则会造成死锁。</p></li></ul><p>示例用法：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &lt;mutex&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::mutex mutex;</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> someFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    mtx</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //或者使用mtx.try_lock()尝试非阻塞锁定</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //临界区代码</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    mtx</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-2-递归互斥量-std-recursive-mutex" tabindex="-1"><a class="header-anchor" href="#_1-2-递归互斥量-std-recursive-mutex"><span>1.2 递归互斥量 <code>std::recursive_mutex</code></span></a></h3><p><code>std::recursive_mutex</code>是递归互斥量，它允许同一个线程多次获取锁</p><p>特点如下：</p><ul><li><p><strong>递归性：</strong> 允许同一个线程在已经拥有锁的情况下再次获取锁，避免了死锁。</p></li><li><p><strong>相对低效：</strong> 相比<code>std::mutex</code> ,由于需要额外的管理递归深度，可能会略微低效。</p></li></ul><p>示例用法：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &lt;mutex&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::recursive_mutex rmtx;</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> someFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    rmtx</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //可以再次在同一个线程中锁定</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    someFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //递归调用，再次锁定</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    rmtx</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-3-带时间的互斥量std-timed-mutex" tabindex="-1"><a class="header-anchor" href="#_1-3-带时间的互斥量std-timed-mutex"><span>1.3 带时间的互斥量<code>std::timed_mutex</code></span></a></h3><p><code>std::timed_mutex</code>是带超时功能的互斥量，它允许在等待一段时间后自动放弃等待。</p><p>特点：</p><ul><li><p><strong>超时等待：</strong> 允许在尝试锁定时设置最大等待时间，避免长时间等待导致程序假死。</p></li><li><p><strong>try_lock_for() 和 try_lock_until() :</strong> 提供了超时等待的具体实现方法。</p></li></ul><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &lt;mutex&gt;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &lt;chrono&gt;</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::timed_mutex tmtx;</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> someFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">tmtx</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">try_lock_for</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">chrono</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">seconds</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">))) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //成功获取锁</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //可能的临界区代码</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        tmtx</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">        //超时处理    </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-4-灵活的锁管理器std-unique-lock" tabindex="-1"><a class="header-anchor" href="#_1-4-灵活的锁管理器std-unique-lock"><span>1.4 灵活的锁管理器<code>std::unique_lock</code></span></a></h3><p><code>std::unique_lock</code>是一个灵活的锁管理器，可以用于管理<code>std::mutex</code> 、</p><p><code>std::recursive_mutex</code> 、<code>std::timed_mutex</code> 等。</p><p>特点：</p><ul><li><strong>灵活性：</strong> 相比于直接使用<code>lock()</code>和<code>unlock()</code> ， <code>std::unique_lock</code>提供了更多的灵活性，如可以在构造时锁定，析构时自动解锁。</li><li><strong>条件变量配合：</strong> 与<code>std::condition_variable</code>结合使用，实现复杂线程间同步和通信。</li></ul><p>示例用法：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &lt;mutex&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &lt;condition_variable&gt;</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::mutex mtx;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::condition_variable cv;</span></span>\n<span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> someFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">    std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::unique_lock</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::mutex</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> lock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(mtx);</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //可能的临界区代码</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    cv</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(lock);</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //等待条件变量通知</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //继续执行</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-5-简单的锁管理器-std-lock-guard" tabindex="-1"><a class="header-anchor" href="#_1-5-简单的锁管理器-std-lock-guard"><span>1.5 简单的锁管理器 <code>std::lock_guard</code></span></a></h3><p><code>std::lock_guard</code>是一个简单的锁管理器，用于管理<code>std::mutex</code>。</p><p>特点：</p><ul><li><p><strong>简洁性：</strong> 使用<code>std::lock_guard</code>可以确保在作用域结束时自动解锁，避免了手动调用<code>unlock()</code>导致的遗漏。</p></li><li><p><strong>RALL(资源获取即初始化)：</strong> 利用对象生命周期管理锁的获取和释放</p></li></ul><p>示例用法：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &lt;mutex&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::mutex mtx;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> someFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">    std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::lock_guard</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::mutex</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> lock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(mtx);</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //临界区代码</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //作用域结束时自动解锁</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结：</span></a></h3><p><code>&lt;mutex&gt;</code> 头文件提供了多种锁机制，用于在多线程编程中确保数据的安全访问和线程间的同步。选择合适的锁取决于具体的需求和场景，可以通过<code>std::mutex</code> 、 <code>std::recursive_mutex</code> 、 <code>std::timed_mutex</code> 、 <code>std::unique_lock</code> 和 <code>std::lock_guard</code> 等灵活地实现线程间的互斥和同步。</p>',34)],l={},t=(0,n(6262).A)(l,[["render",function(s,i){return(0,a.uX)(),(0,a.CE)("div",null,e)}]]),h=JSON.parse('{"path":"/language/cpp/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.html","title":"线程间通信","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-07-31T00:00:00.000Z","category":["C++"],"tag":["C++","进程","操作系统"],"sticky":true,"order":1,"author":"Ms.Huang"},"headers":[{"level":2,"title":"1.锁机制（mutex）","slug":"_1-锁机制-mutex","link":"#_1-锁机制-mutex","children":[{"level":3,"title":"1.1 基本互斥锁std::mutex","slug":"_1-1-基本互斥锁std-mutex","link":"#_1-1-基本互斥锁std-mutex","children":[]},{"level":3,"title":"1.2 递归互斥量 std::recursive_mutex","slug":"_1-2-递归互斥量-std-recursive-mutex","link":"#_1-2-递归互斥量-std-recursive-mutex","children":[]},{"level":3,"title":"1.3 带时间的互斥量std::timed_mutex","slug":"_1-3-带时间的互斥量std-timed-mutex","link":"#_1-3-带时间的互斥量std-timed-mutex","children":[]},{"level":3,"title":"1.4 灵活的锁管理器std::unique_lock","slug":"_1-4-灵活的锁管理器std-unique-lock","link":"#_1-4-灵活的锁管理器std-unique-lock","children":[]},{"level":3,"title":"1.5 简单的锁管理器 std::lock_guard","slug":"_1-5-简单的锁管理器-std-lock-guard","link":"#_1-5-简单的锁管理器-std-lock-guard","children":[]},{"level":3,"title":"总结：","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1722604802000,"updatedTime":1722692967000,"contributors":[{"name":"haley","email":"huanghongweimax@163.com","commits":2}]},"readingTime":{"minutes":2.67,"words":802},"filePathRelative":"language/cpp/进程间通信.md","localizedDate":"2024年7月31日","excerpt":"\\n<h2>1.锁机制（mutex）</h2>\\n<h3>1.1 基本互斥锁<code>std::mutex</code></h3>\\n<p><code>std::mutex</code>是最基本的互斥变量，他提供了最基本的互斥访问控制。</p>\\n<p>特点如下：</p>\\n<ul>\\n<li>\\n<p><strong>互斥访问：</strong> 只有一个线程可以锁定<code>std::mutex</code>对象，其他线程必须等待解锁后才能继续执行。</p>\\n</li>\\n<li>\\n<p><strong>不可重入：</strong> 同一个线程不能多次锁定同一个<code>std::mutex</code>否则会造成死锁。</p>\\n</li>\\n</ul>"}')}}]);